"""
Simon Matusek
Oct. 10-20 2020
RPG mini-world (final ver.): 
user 'walks' around a small area,
talks to/shoots 4 npcs,
and goes in a cave ('boss fight')
"""

import turtle, time, random



goorno=0
nonopoints=[(-400,300),(-350,300),(-300,300),(-250,300),(-200,300),(-150,300),(-150,350),(-50,-250),(-50,250),(200,0),(400,-100),(400,-50),(400,0),(400,50),(400, 100)]
timefont=("Comic Sans MS", 25, "normal")    #font for timer (in cave)


class NotDice(Exception):   #make sure dice # is valid
    pass

class NotCap(Exception): #make sure to capitalize name
    pass







def movcheck(direction, key):
    """
    give orientation of turtle, gives boolean output
    
    ex. var=movcheck(180,'w') - turtle.pos()=(450,450)
    var==True
    """
    
    if npc4.pos()==(-50,-250):
        try:
            nonopoints.insert(7,(-50,-250)) #put in most efficient place for (sorted) list
            nonopoints.remove((-50,-300))   #allow user to go there
            
        except ValueError:
            nonopoints.remove((-50,-250))   #removes dupliacate coord in list if no (-50,-300)
    elif npc4.pos()==(-50,-300):
        try:
            nonopoints.insert(7,(-50,-300))
            nonopoints.remove((-50,-250))
            
        except ValueError:                  #removes dupliacate coord in list if no (-50,-250)
            nonopoints.remove((-50,-300))

    
    direction=direction
    if key=='s':        #while facing backwards, 
        direction+=180  #check as if facing forwards that way
    
    #note: direction == 360 or 450 same as direction == 0 or 90
    #needed because of if key=='s'
        
    if ((direction==0 or direction==360) and (xhero+50)>=450) or (direction==180 and (xhero-50)<=-450):
        return False 	#don’t allow input
    elif ((direction==90 or direction==450) and (yhero+50)>=400) or (direction==270 and (yhero-50)<=-400):
        return False	#don’t allow input

	
    for i in nonopoints:	#coords with (-)500 in them already checked for
        
        if yhero==i[1]:     #i[1] is y-coord of nonopoint
            if ((direction==0 or direction==360) and (xhero+50)==i[0]) or (direction==180 and (xhero-50)==i[0]):
                return False
        elif xhero==i[0]:     #i[0] is x-coord of nonopoint
            if ((direction==90 or direction==450) and (yhero+50)==i[1]) or (direction==270 and (yhero-50)==i[1]):
                return False

            
    return True     #either it works or it decides to die of death







def movf():
    """
    moves turtle fwd by 50 px
    """
    
    if fmovable:	#allow for “w” input
        hero.fd(50)
    else:
        print("You cannot go that way.")
        
    #print(hero.pos(),orient)       #debugging
    yhero=hero.ycor()   #upcate coords again if attempted movement
    xhero=hero.xcor()

    #time.sleep(0.5)         #meant to slow down, but just
                             #makes inputs lag and queue up behind 
                             #each other, then execute all @ same time
def movb():
    """
    moves turtle back by 50 px
    """
    if bmovable:
        hero.bk(50)
    else:
        print("You cannot go back that way.")
        
    #print(hero.pos(),orient)       #debugging
    yhero=hero.ycor()   #upcate coords again if attempted movement
    xhero=hero.xcor()

    #time.sleep(0.5)    #meant to slow down       


def rotaL():
    """
    rotates turtle left by 90 degrees
    """
    global orient, goorno
    
    hero.lt(90)
    orient=hero.heading()   #update variable
    
    goorno=random.random()  #for pathfind()
    pathfind(goorno)
    
    if npc4.pos()==(xhero,yhero): print("Get out of me.")   #print if inside npc4

    #time.sleep(0.5)
    
def rotaR():
    """
    rotates turtle right by 90 degrees
    """
    global orient, goorno
    
    hero.rt(90)
    orient=hero.heading()   #update variable
    
    goorno=random.random()  #for pathfind()
    pathfind(goorno)
    
    if npc4.pos()==(xhero,yhero): print("Get out of me.")   #print if inside npc4

    #time.sleep(0.5)







def helpu():
    """
    print controls for the game
    """
    print(f"Goal: Wander around, you may find some cool stuff")  #instructions/controls
    print("W/S: Move forward/back\nA/D: Rotate left/right\nE: Interact\nQ: Gun\nH: Help")









def pathfind(move):
    """
    how NPC4(ghost) moves from tile 1 to tile 2
    tells user to move away if inside npc4
    """  
    if move>0.5:    #move generated by goorno, when user rotates  
        npc4.setpos(-50,-250)
    else:
        npc4.setpos(-50,-300)

    










def towngen():
    """
    makes background for "town"
    """
    global townwindow, drawer   #to be able to declare other turtles out of func
    townwindow=turtle.Screen()
    townwindow.screensize(900,800)
    townwindow.bgcolor('lightgreen')
    
    drawer=turtle.RawTurtle(townwindow)
    drawer.hideturtle()     #declare background turtle
    drawer.color('white')
    drawer.width(7)
    drawer.speed(0)
    
    drawer.penup()
    drawer.setpos(-150,400) #drawing fence
    drawer.pendown()
    
    drawer.setpos(-150,300)
    drawer.setpos(-450,300)
    drawer.penup()      
    
    drawer.setpos(450,100)  #draw cave enter
    drawer.begin_fill()
    drawer.color('black')
    drawer.pendown()
    
    for i in [(400,100), (400,-100), (450,-100)]:
        drawer.setpos(i)    #draw cave hole
    drawer.end_fill()     #Fill rectangle

    drawer.color('darkgreen')

    drawer.penup()  #draw border
    drawer.setpos(450,400)
    drawer.pendown()
    
    for i in ((450,-400),(-450,-400),(-450,400),(450,400)):
        drawer.setpos(i)
    
    #drawer.width(2)     #draw grid
    #for l in range(-450,500,50): #debugging purposes
    #    drawer.penup()
    #    drawer.setpos(l,-500)
    #    drawer.pendown()
    #    drawer.setpos(l,500)
    #    drawer.penup()
    #    drawer.setpos(-500,l)
    #    drawer.pendown()
    #    drawer.setpos(500,l)








        
def cavegen():
    """
    makes background for cave
    """
    townwindow.screensize(900,700)
    townwindow.bgcolor('gray')
    
    cdrawer=turtle.RawTurtle(townwindow)
    cdrawer.hideturtle()         
    cdrawer.color('white')
    
    
    cdrawer.speed(0)
    
    cdrawer.penup()
    cdrawer.setpos(-450,100)
    
    cdrawer.begin_fill()
    cdrawer.pendown()

    for i in ((-450,-100), (-400,-100), (-400,100)):
        cdrawer.setpos(i)  #draw cave exit
    cdrawer.end_fill()    #Fill rectangle

    cdrawer.penup()
    cdrawer.width(7)
    
    cdrawer.color('black')
    cdrawer.setpos(450,350)
    cdrawer.pendown()
    
    for i in ((450,-350),(-450,-350),(-450,350),(450,350)):
        cdrawer.setpos(i)  #draw border
    cdrawer.end_fill()    #Fill rectangle








def gun():
    """
    Draw small white line from hero
    """
    hero.width(3)
    hero.pendown()		
    hero.color('white','green')
    
    hero.fd(100)
    hero.bk(100)
    hero.penup()
    hero.color('black','green')
    
    time.sleep(0.1)
    hero.clear()        #delete trail








#interaction procedures
    

def dicegame():
    """
    input the dice # you want
    output the # of rolls it takes to get it
    """
    roll=0
    count=0
    print()
    while True: #retry until valid # given
        
        try:
            want = int(input("What number do you want me to roll? "))
            if not(1<=want<=6):
                raise NotDice   #check for valid range
            else:
                break           #leave if valid input
            
        except ValueError:
            print("Not an integer dice roll. Try again.")
        except NotDice:
            print("Not a valid dice roll (1-6). Try again.")



    while roll != want:
        
        roll=random.randint(1,6)        #random roll
        time.sleep(0.15)            
        print(f"Roll{count+1:3d}:{roll:2d}")    #output results
        count+=1
        
    return count  #return dice roll count










def cavetalk():
    """
    exits town window if possible
    """
    
    global cavein
    
    if enterable:
        print()
        print("You are entering the ominous and obviously dangerous cave…")
        cavein=True     #to exit town's loop
		
    elif not(alive[2]) and not(enterable):
        print()
        print("Restart. You cannot go in the cave.") #softlock check
        
        score=random.randint(0,9)   #arbitrary score
        print(f"This is game over for {name}, whose life was a{score:2d}/10")
        print()
        cavein=True
        
    else:
        print("You cannot go in the cave.")


def cavegun():
    """
    useless interaction
    """
    if enterable:
        gun()
        print("You blindly shoot into the dark cave. Nothing happens, but you scare a bat.")
    else:
        gun()
        print("How would a gun help you here? Break the wall?")










def npc1talk():
    """
    asks for (valid) age, insults you
    """
    if alive[0]:    #can't talk to dead people
        try:
            age = turtle.numinput("Hello!","You’re new here! How old are you?",0,1,120)
            print(f"When I was your age i was twice your age, so {int(age*2)} years old")
        except TypeError:   #if user cancels text box
            print(end="")

def npc1gun():
    """
    kills npc1
    """
    gun()
    print("Oh no, you shot me. That sucks.")
    npc1.color('black','grey')  #show user who's dead
    alive[0]=False









def npc2talk():
    """
    asks to play a dice game behind fence
    """    
    if alive[1]:

        print("Haha! You can’t touch me!")

        try:
            response = turtle.textinput("Dice game","Would you like to play a Game? (Y/N)")

            if response[0]=="Y" or response[0]=="y":
                print(f"Well, it took me {dicegame()} rolls to get your number. Bye!")
            else:
                print("Aww...")
    
        except IndexError:  #if user enters nothing
            print("Hello?")
        except TypeError:   #if user cancels text box
            print(end="")

def npc2gun():
    """
    kills dice man (npc2)
    """ 
    gun()
    try:
        response = turtle.textinput("What?","Oh god! You shot me! You monster! What?!")
        
        if response[0]=="": raise IndexError
        
        print(f'"{response}"!? How dare you! I am dead!')
        
    except IndexError:  #if user enters nothing
        print('Nothing!? How dare you! I am dead!')
    except TypeError:   #if user cancels text box
        print('How dare you run away! I am dead!')
        
    print("Goodbye.")
    npc2.color('black','grey') #show user who's dead
    alive[1]=False 









def npc3talk():
    """
    asks if you want to go in cave
    allows you to go in cave
    """    
    if alive[2]:
        try:
            y_or_n = turtle.textinput("Old Man","Would you like to follow me into the cave over there? (Y/N)")
        
            if y_or_n[0]== "y" or y_or_n[0] == "Y":
                print("Then go!\n(Enter by pressing 'e' nearby)")
            
                global enterable
                enterable =True
            else:
                print("Aww...")
            
        except IndexError:  #if user enters nothing
            print("Nothing?")
        except TypeError:   #if user cancels text box
            print(end="")
	
def npc3gun():
    """
    softlocks user if not interacted with yet
    """
    gun()
    print("You haven’t seen the last of me! (hint hint)")
    
    npc3.color('black','grey')
    alive[2]=False #show user who's dead









def npc4talk():
    """
    interacion has no effect
    """ 

    try:
        response = turtle.textinput("Odd Thing","What am I?")

        if response[0]=="": raise IndexError

        if response != "zombie":
            print(f"A {response}? You silly mute and emotionless triangle!")
            
        else:
            print("Correct!")

    except IndexError:
        print("Too scared to answer?")
    except TypeError:
        print(end="")
    

def npc4gun():
    """
    interacion has no effect
    """
    gun()
    print("Hehe. I'm already dead, dumdum")
    #npc4 cannot die, because i said so











def interranges(x,y):   #hero coords
    """
    defines what procedures are called
    ex.
    hero.pos()=(-50.00,200.00)
    'e' is bound to npc3talk()
    'q' is bound to npc3gun()
    """

    if -400<=x<=-300 and 250<=y<=400: #larger range for npc2 because of fence
        townwindow.onkeypress(npc2talk,'e')
        townwindow.onkeypress(npc2gun,'q')
        
    elif -100<=x<=0 and 200<=y<=300:		#for npc1,2,3,etc.
        townwindow.onkeypress(npc1talk,'e')
        townwindow.onkeypress(npc1gun,'q')
        
    elif -100<=x<=0 and -350<=y<=-200:	
        townwindow.onkeypress(npc4talk,'e')
        townwindow.onkeypress(npc4gun,'q')
        
    elif 150<=x<=250 and -50<=y<=50:
        townwindow.onkeypress(npc3talk,'e')
        townwindow.onkeypress(npc3gun,'q')
        
    elif 350<=x<=450 and -150<=y<=150:	
        townwindow.onkeypress(cavetalk,'e')
        townwindow.onkeypress(cavegun,'q')
        
    else:		
        townwindow.onkeypress(None,'e') #un-bind if not in any range
        townwindow.onkeypress(gun,'q')









def bossgun():
    """
    same thing as gun(), but longer 'range'
    allows user to 'kill' npc3 again and win game
    """
    hero.width(3)
    hero.color('white','green')
    
    hero.pendown()    
    hero.fd(600)
    hero.bk(600)
    hero.penup()
    
    hero.color('black','green')
    
    time.sleep(0.1)
    hero.clear()        #delete trail

    if orient==0: alive[3]=False      #kill boss










#                           #
##                         ##
### Main Code Starts HERE ###
##                         ##
#                           #




while True:   
    
    print("Hello! Welcome to Simple Town!") #intro
    
    while True:
        try:
            name=input("What is your name? ")
            
            for i in name.split():
                if not('A'<=i[0]<='Z'):  #first letter must be capitalized
                    raise NotCap
            if name=="": raise IndexError
            break
        
        except NotCap:
            print("Please capitalise that, thank you.")
        except IndexError:
            print("Enter something please.")

    name+=" The Great"      #your RPG name



    

    print(f"Welcome, {name}!")  #instructions/controls
    time.sleep(0.3)     #user has time to read one at a time
    print("By the way, you may or may not have a gun...")
    time.sleep(0.3)
    print("Let’s hop in now, shall we?")
    time.sleep(0.3)
    print("Goal: Wander around, you may find some cool stuff")
    time.sleep(0.3)
    print("W/S: move forward/back")
    time.sleep(0.3)
    print("A/D: rotate left/right")
    time.sleep(0.3)
    print("E: Interact")
    time.sleep(0.3)
    print("Q: Gun")
    time.sleep(0.3)
    print("H: Help")
    time.sleep(3)   #let user read






    
    alive=[True,True,True,True]     #resurrect NPCs
    enterable,cavein=False,False    #reset variables


    
    towngen()   #town scene starts here


    
    townwindow.onkeypress(helpu,'h')
    
    townwindow.onkeypress(movf,'w')     #bind movement keys
    townwindow.onkeypress(rotaL,'a')
    townwindow.onkeypress(movb,'s')
    townwindow.onkeypress(rotaR,'d')
    
    townwindow.onkeypress(None,'e') #unbind interact key initially
    townwindow.onkeypress(gun,'q')
    
    hero=turtle.RawTurtle(townwindow)   #set user's turtle
    npc1=turtle.RawTurtle(townwindow)   #set all NPCs
    npc2=turtle.RawTurtle(townwindow)
    npc3=turtle.RawTurtle(townwindow)
    npc4=turtle.RawTurtle(townwindow)   #set ghost

    hero.speed(0)   #no animation times
    npc1.speed(0)
    npc2.speed(0)
    npc3.speed(0)
    npc4.speed(0)

    hero.penup()    #not snalis
    npc1.penup()
    npc2.penup()
    npc3.penup()
    npc4.penup()

    hero.shape('triangle')
    npc1.shape('circle')
    npc2.shape('circle')
    npc3.shape('circle')
    npc4.shape('circle')

    hero.color('black','green')
    npc3.color('black', 'red') #red npc w/black outline
    npc4.color('black', 'gainsboro') #white npc w/black outline

    hero.shapesize(2, 3, 3)
    npc1.shapesize(2.3, 2.3, 3) #double-ish size+outline
    npc2.shapesize(2.4, 2.4, 3) 
    npc3.shapesize(2.3, 2.3, 3) 
    npc4.shapesize(2.5, 2.5, 3) 

    
    hero.setpos(-400,-300)  #put them in place
    npc1.setpos(-50,250)
    npc2.setpos(-350,350)
    npc3.setpos(200,0)
    npc4.setpos(-50,-300)







    
    while not(cavein):  #from cavetalk()

        orient=round(hero.heading())   
        yhero=round(hero.ycor())
        xhero=round(hero.xcor())   #update hero coords
        
        fmovable=movcheck(orient,"w")
        bmovable=movcheck(orient,"s")  #update movability
        
        interranges(xhero,yhero)  #update possible interactions
                
        pathfind(goorno)  #update npc4 position
        townwindow.listen() #must be in loop or will stop 
                            #receiving inputs after 1 interaction



    
    time.sleep(0.7)
    
    townwindow.clearscreen()    #"close" townwindow


    
    if not(alive[2]) and not(enterable): continue   #restart 
    









    cavegen()   #cave scene starts here

    npc3=turtle.RawTurtle(townwindow)   #set up hero/npc3/timer
    hero=turtle.RawTurtle(townwindow)
    board=turtle.RawTurtle(townwindow)

    board.hideturtle()
    
    hero.penup()
    npc3.penup()
    board.penup()
    
    npc3.speed(0)
    hero.speed(0)
    board.speed(0)

    npc3.shape('circle')
    hero.shape('triangle')
    
    npc3.color('black', 'red') #red npc w/black outline
    hero.color('black','green')
    board.color('white')  #white font
    
    npc3.shapesize(2.3,2.3,3) # double size
    hero.shapesize(2,3,3)
    
    npc3.setpos(300,0)
    hero.setpos(-310,0)
    board.setpos(0,250)

    npc3.seth(180)      #face towards hero
    



    
    fmovable,bmovable=False,False   #cannot move here

    townwindow.onkeypress(helpu,'h')
    townwindow.onkeypress(movf,'w')     #bind movement keys
    townwindow.onkeypress(rotaL,'a')
    townwindow.onkeypress(movb,'s')
    townwindow.onkeypress(rotaR,'d')
    townwindow.onkeypress(None,'e')
    townwindow.onkeypress(bossgun,'q')  #bind 'q' to new gun procedure



    print()
    print("You feel a shiver down your spine. You can’t move.")
    print("(You also feel a bear trap on your feet.)")

    print(f"You fell for my trap {name}, I never thought you could be so stupid!")
    print()
    print("Uh oh.")
    print()



    timegoal=round(time.time()+15)	    #time since epoch +15 seconds
    timepass=time.time()	    #updated time since epoch 


    
    townwindow.listen()
    
    while timepass < timegoal:

        
        if (timegoal-timepass)%0.5==0:
            npc3.fd(7)
        
            board.clear()   #update countdown
            board.write(round(timegoal-timepass+0.01),False,'left', timefont)   
                #round() rounds to half-even, so round(2.5)=2 and round(1.5)=2, so even 
                #numbers print more times than odd, so add 0.01 because round(2.51)=3
            
            
        if not(alive[3]):       #press Q to win (while facing right) 
                break               #don't let "you lose" print
            
        timepass=round(time.time(),1)    #update time
        
    else:
        print("You lose!")      #prints only if loop is not broken






    if not(alive[3]):        
        try:
            prize=turtle.textinput("You Win!","What do you win? I don’t know…")
            if prize[0]=='': raise TypeError
            print(f"Well then, our hero {name} wins {prize} today!")

        except TypeError:   #if user cancels text box
            print(f"Well then, {name} wins nothing today...")
                
        except IndexError:  #if user enters nothing
            print(f"Well then, {name} gets nothing from this adventure.")
            

        

    townwindow.clearscreen()    #end game
    print()

    try:
        play=turtle.textinput("bababooey","Play again? (Y/N) ")
        
        if play[0] == 'N' or play[0] == 'n':
            break
        else:
            raise IndexError    #custom error would have same output
        
    except IndexError:
        print("I'll take that as a yes!")   
    except TypeError:
        print("I'm assuming you mean no...")
        break






print("--END--")
turtle.bye()    #close window, end game






